using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Cave.Data;

/// <summary>Code generator for IDatabase instances.</summary>
public class DatabaseInterfaceGenerator
{
    sealed record TableInfo(RowLayout Layout, string TableNameAtDatabase, string ClassName, string GetterName, InterfaceGeneratorOptions Options) : BaseRecord;

    #region Private Fields

    readonly Dictionary<string, TableInfo> tables = new();
    string? footer;
    string? header;

    #endregion Private Fields

    #region Private Methods

    string GetName(string text) => NamingStrategy.GetNameByStrategy(text);

    void WriteHeaderAndFooter()
    {
        var generator = typeof(DatabaseInterfaceGenerator);
        var code = new StringBuilder();
        code.AppendLine("//-----------------------------------------------------------------------");
        code.AppendLine("// <summary>");
        code.AppendLine($"// Autogenerated Database Interface Class");
        code.AppendLine("// </summary>");
        code.AppendLine("// <auto-generated />");
        code.AppendLine("//-----------------------------------------------------------------------");
        code.AppendLine();
        code.AppendLine("#nullable enable");
        code.AppendLine();
        code.AppendLine($"namespace {NameSpace}");
        code.AppendLine("{");
        code.AppendLine($"\t/// <summary>Provides access to table structures for database {Database.Name}.</summary>");
        if (Options.VersionHeader)
        {
            code.AppendLine($"\t[System.CodeDom.Compiler.GeneratedCode(\"{generator.FullName}\", \"{generator.Assembly.GetName().Version}\")]");
        }
        else
        {
            code.AppendLine($"\t[System.CodeDom.Compiler.GeneratedCode(\"{generator.FullName}\", null)]");
        }
        code.AppendLine($"\tpublic static partial class {ClassName}");
        code.AppendLine("\t{");
        code.AppendLine("\t\tstatic Cave.Data.IDatabase? database;");
        code.AppendLine();
        code.AppendLine("\t\t/// <summary>Gets the used database instance.</summary>");
        code.AppendLine("\t\tpublic static Cave.Data.IDatabase Database => database ?? throw new InvalidOperationException(\"Database is not connected!\");");
        code.AppendLine();
        code.AppendLine("\t\t/// <summary>Gets or sets the flags used when accessing table instances.</summary>");
        code.AppendLine("\t\tpublic static Cave.Data.TableFlags DefaultTableFlags { get; set; }");
        code.AppendLine();
        code.AppendLine($"\t\t/// <summary>Connects to the {Database.Name} database.</summary>");
        code.AppendLine("\t\t/// <param name=\"storage\">Cave.Data.IStorage instance to use.</param>");
        code.AppendLine("\t\t/// <param name=\"createIfNotExists\">Create the databaseName if its not already present.</param>");
        code.AppendLine("\t\t/// <returns>A new <see cref=\"Cave.Data.IDatabase\" /> instance.</returns>");
        code.AppendLine("\t\tpublic static void Connect(Cave.Data.IStorage storage, bool createIfNotExists = false)");
        code.AppendLine("\t\t{");
        code.AppendLine($"\t\t\tdatabase = storage.GetDatabase(\"{Database.Name}\", createIfNotExists);");
        code.AppendLine("\t\t}");
        code.AppendLine();
        code.AppendLine("\t\t/// <summary>Gets or sets the function used to retrieve tables from the database.</summary>");
        code.AppendLine("\t\tpublic static Func<string, Cave.Data.ITable> GetTable { get; set; } = (tableName) => Database.GetTable(tableName, DefaultTableFlags);");
        header = code.ToString();
        code = new StringBuilder();
        code.AppendLine("\t}");
        code.AppendLine("}");
        footer = code.ToString();
    }

    #endregion Private Methods

    #region Public Constructors

    /// <summary>Initializes a new instance of the <see cref="DatabaseInterfaceGenerator" /> class.</summary>
    /// <param name="database">Database to use.</param>
    /// <param name="className">Name of the class to generate (optional).</param>
    public DatabaseInterfaceGenerator(IDatabase database, string? className = null) : this(database, className, null) { }

    /// <summary>Initializes a new instance of the <see cref="DatabaseInterfaceGenerator" /> class.</summary>
    /// <param name="database">Database to use.</param>
    /// <param name="className">Name of the class to generate (optional).</param>
    /// <param name="nameSpace">The namespace to use for all classes (defaults to "Database").</param>
    public DatabaseInterfaceGenerator(IDatabase database, string? className = null, string? nameSpace = null)
    {
        Database = database ?? throw new ArgumentNullException(nameof(database));
        ClassName = className ?? GetName(database.Name) + "Db";
        NameSpace = nameSpace ?? "Database";
    }

    #endregion Public Constructors

    #region Public Properties

    /// <summary>Gets the name of the generated class.</summary>
    public string ClassName { get; set; }

    /// <summary>Gets the used database instance.</summary>
    public IDatabase Database { get; }

    /// <summary>Gets the filename used at <see cref="Save(string)"/>.</summary>
    public string? FileName { get; set; }
    /// <summary>Gets the namespace of the generated class.</summary>
    public string NameSpace { get; set; }

    /// <summary>Naming strategy for classes, properties, structures and fields.</summary>
    public NamingStrategy NamingStrategy { get; set; } = NamingStrategy.PascalCase;

    /// <summary>Options for code generation.</summary>
    public InterfaceGeneratorOptions Options { get; } = new();

    #endregion Public Properties

    #region Public Methods

    /// <summary>Adds a table to the database interface code. This does not generate the table class!</summary>
    /// <param name="tableLayout">Layout of the table</param>
    /// <param name="tableCodeResult">The table to add.</param>
    /// <param name="getterName">Name of the getter in the resulting class (optional).</param>
    public GenerateTableCodeResult Add(RowLayout tableLayout, GenerateTableCodeResult tableCodeResult, string? getterName = null)
    {
        tableCodeResult.TableName ??= tableLayout.Name;
        if (tableCodeResult.TableName is null) throw new InvalidOperationException("One of tableCodeResult.TableName or tableLayout.Name has to be set!");
        tableCodeResult.DatabaseName ??= GetName(Database.Name);
        tableCodeResult.GetterName = getterName ?? GetName(tableCodeResult.TableName);
        tableCodeResult.ClassName ??= tableCodeResult.DatabaseName + tableCodeResult.TableName + "Row";
        tables.Add(tableLayout.Name, new TableInfo(tableLayout, tableCodeResult.TableName, tableCodeResult.ClassName, tableCodeResult.GetterName, Options));
        return tableCodeResult;
    }

    /// <summary>Generates the interface code.</summary>
    /// <returns>Returns c# code.</returns>
    public string Generate()
    {
        WriteHeaderAndFooter();

        var result = new StringBuilder();
        result.Append(header);
        foreach (var table in tables.Values.OrderBy(t => t.ClassName))
        {
            result.AppendLine();
            var singleIdentifier = table.Layout.SingleIdentifier;
            var strongTypedIdentifier = singleIdentifier != null && !Options.DisableKnownIdentifiers;
            var typeString = strongTypedIdentifier ? $"{singleIdentifier!.DotNetTypeName}, {table.ClassName}" : table.ClassName;
            var genericString = strongTypedIdentifier ? $"TKey, TStruct" : "TStruct";
            result.AppendLine($"\t\tstatic Cave.Data.ITable<{typeString}>? table{table.GetterName};");
            result.AppendLine();
            result.AppendLine($"\t\t/// <summary>Gets a new <see cref=\"Cave.Data.ITable{{{genericString}}}\"/> ({typeString}) instance for accessing the <c>{table.TableNameAtDatabase}</c> table.</summary>");
            result.AppendLine($"\t\tpublic static Cave.Data.ITable<{typeString}> {table.GetterName} => table{table.GetterName} ??= new Cave.Data.Table<{typeString}>(GetTable(\"{table.TableNameAtDatabase}\"));");
        }

        result.Append(footer);
        return result.ToString();
    }

    /// <summary>Builds the csharp code file containing the row layout structure and adds it to the interface.</summary>
    /// <param name="table"></param>
    /// <param name="databaseName">The database name (only used for the structure name).</param>
    /// <param name="tableName">The table name (only used for the structure name).</param>
    /// <param name="className">The name of the class to generate.</param>
    /// <param name="structFile">The table struct file name (defaults to classname.cs).</param>
    /// <param name="getterName">Name of the table getter (optional).</param>
    public GenerateTableCodeResult GenerateTableStructFile(ITable table, string? databaseName = null, string? tableName = null, string? className = null,
        string? structFile = null, string? getterName = null)
    {
        if (table == null)
        {
            throw new ArgumentNullException(nameof(table));
        }

        var result = new TableInterfaceGenerator()
        {
            Options = Options,
            Layout = table.Layout,
            DatabaseName = databaseName ?? table.Database.Name,
            TableName = tableName ?? table.Name,
            ClassName = className,
            NameSpace = NameSpace,
            NamingStrategy = NamingStrategy,
        }.GenerateStructFile(structFile);
        result = Add(table.Layout, result, getterName);
        return result;
    }

    /// <summary>Saves the output of <see cref="Generate" /> to the specified filename.</summary>
    /// <param name="fileName">Filename to save to.</param>
    public void Save(string? fileName = null)
    {
        if (fileName is not null || FileName is null)
        {
            FileName = fileName ?? ClassName + ".cs";
            FileName = Path.Combine(Options.OutputDirectory, FileName);
        }
        File.WriteAllText(FileName, Generate());
    }

    #endregion Public Methods

}
